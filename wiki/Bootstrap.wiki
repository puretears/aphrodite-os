#labels OS,Bootstrap
#Process about how the bootstrap code loads the loader into memory.

= Introduction =

Aphrodite OS 启动代码的详细设计。

= How Aphrodite OS is booted up =

一个操作系统的启动分成三个过程：

 * 首先是MBR被加载到内存里。MBR中代码的作用通常是加载另一个程序到内存里，并把控制权交给它，我们管这个程序叫做Loader。之所以要加载Loader，是因为内核初始化的代码通常要大于512字节，不能在MBR中全部完成。

 * Loader为内核进行必要的初始化工作，之后在启动媒介中找到内核，把内核加载到内存中，然后交出控制权。

 * 内核接管控制权，初始化，开始执行。

= Why we started from a loader? =

 * 头开始体验操作系统符合人们的思维习惯；

 * 自己写的Loader便于在内核发生故障时进行调试；

其实，无论是MBR在启动媒介中寻找Loader，还是Loader在启动媒介中寻找内核，道理都是一样的，MBR或者Loader要能够识别启动媒介的文件系统，所以，我们可以从最简单的启动媒介开始体验——软盘。软盘使用的是FAT12文件系统，可以参考。这里说一些我们用的到的东西：

= Details of FAT12 MBR =
FAT12的MBR格式分成五部分：

||一个跳转到MBR代码的short跳转指令||
||一个nop指令||
||BPB结构||
||MBR代码||
||0xAA55结束标记||

写成一个nasm的代码框架如下：
{{{
    org 07C00H
    nop

    jmp short LABLE_START

    ; BPB definition here

LABEL_START:

    ; Bootstrap codes here

    times (510 - ($ - $$)) db 0
    dw 0xAA55
}}}

首先来看BPB的定义：
{{{
    ;BPB here
    BS_OEMName          db "PURETEAR"
    BPB_BytesPerSec     dw 0200H
    BPB_SecPerClus      db 1
    BPB_RsvdSecCnt      dw 1
    BPB_NumFATs         db 2
    BPB_RootEntCnt      dw 0E0H
    BPB_TotSec16        dw 0B40H
    BPB_Media           db 0xF0
    BPB_FATSz16         dw 9
    BPB_SecPerTrk       dw 12H 
    BPB_NumHeads        dw 2
    BPB_HiddenSec       dd 0
    BPB_TotSec32        dd 0
    BS_DrvNum           db 0
    BS_Reserved1        db 0
    BS_BootSig          db 0x29
    BS_VolID            dd 0
    BS_VolLab           db "puretears  "
    BS_FileSysType      db "FAT12   "
}}}
其中，需要我们关注的成员有以下几个：
||成员||含义||FAT12对应值||
||BPB_BytesPerSec||每一个扇区的字节数||0200H||
||BPB_NumFATs||FAT12拥有的FAT表数量||2||
||BPB_RootEntCnt||FAT12根目录最大文件数||0E0H||
||BPB_SecPerTrk||每磁道的扇区数||012H||

根据上面的数值，我们可以计算出来一些FAT12常用的数值：

 # FAT表开始扇区号：1
 # FAT表共占用扇区数：18
 # 根目录开始扇区号：SECTOR_OF_ROOTDIR = 9 + 9 + 1 = 19
 # 根目录表最多占用扇区数：TOTAL_ROOTDIR_SEC = BPB_RootEntCnt `*` 32 / 512 = 14

= Some auxiliary functions =
*read_sector*

第一个是用来读软盘的函数，由于int 13H对软盘的读写比较麻烦，我们只需要指定逻辑上我们要读的软盘中的扇区号，要连续读几个扇区以及在es:bx中指定缓冲区的地址，read_sector会自动帮助我们执行读操作。
{{{
; es:bx data buffer
; push starting sector number
; push numbers of sectors want to read
; call read_sector
read_sector:
    enter 6
    push cx
    push dx

    xor dx, dx
    mov ax, [bp + 6] ; starting sector number
    mov cx, SECTORS_PER_TRACK
    div cx

    inc dx
    mov [bp - 2], dx ; sector number

    mov cx, ax
    shr ax, 1
    mov [bp - 4], ax ; track number

    and cx, 1
    mov [bp - 6], cx ; head number
    
    mov ch, [bp - 4]
    mov cl, [bp - 2]
    mov dh, [bp - 6]
    mov dl, 0
    
CONTINUE_READING:
    mov ah, 02H 
    mov al, [bp + 4]
    int 13H 
    jc CONTINUE_READING ; Continue reading until successful
    
    pop dx
    pop cx
    add sp, 6
    leave
    ret 
}}}

*get_fat_entry*

当我们在FAT根目录表中读到了文件的第一个扇区数时，我们还要根据这个扇区数，在FAT table中查询是否还有后续扇区，get_fat_entry便用来进行该项操作。要点是判断在FAT table中的索引是奇数还是偶数，如果是奇数，在读取到相应的fat entry后，要右移四位。
{{{
; push entry_index
; call get_fat_entry
get_fat_entry:
    enter
    push es

    mov ax, BASE_OF_LOADER
    sub ax, 0100
    mov es, ax

    mov ax, [bp + 4] ; entry index of fat table
    ; Whether the index is an odd
    xor dx, dx
    mov bx, 3
    mul bx
    mov bx, 2
    div bx
    cmp dx, 0
    jz EVEN_INDEX
    mov byte [db_odd_index], 1
EVEN_INDEX:
    xor dx, dx
    mov bx, [BPB_BytesPerSec]
    div bx
    xor bx, bx
    add ax, 1
    push ax
    push 2
    call read_sector
    add bx, dx
    mov ax, [es:bx]
    cmp byte [db_odd_index], 1
    jnz GET_ENTRY
    shr ax, 4
GET_ENTRY:
    and ax, 0FFFH
    pop es
    leave
    ret
}}}

*load_file*

把一个指定的文件加载到特定的内存地址，由于我们不仅在MBR加载loader的时候会用到，在loader加载内核的时候同样会用到，因此把这个过程整合成一个函数。输入要加载的文件名，缓冲区地址，load_file会把特定的文件加载到指定的内存。下面是完成的代码。

{{{
; push [address of file name]
; push offset of buffer
; push base of buffer
; call load_file
load_file:
    enter 0, 0
    push es
    push bx
    push cx
    push si
    push di

;Phrase 1: Load all rootdir table entries into memory.
READ_SECTOR:
    ; Load all rootdir sectors into memory
    mov bx, [bp + 6] ; offset of buffer
    mov ax, [bp + 4]
    mov es, ax ; es:bx buffer of the file
    push word [dw_sector_of_rootdir]
    push 14
    call read_sector
    add sp, 4

    push es
    push bx
    push cx
    push si
    push di

;Phrase 1: Load all rootdir table entries into memory.
READ_SECTOR:
    ; Load all rootdir sectors into memory
    mov bx, [bp + 6] ; offset of buffer
    mov ax, [bp + 4]
    mov es, ax ; es:bx buffer of the file
    push word [dw_sector_of_rootdir]
    push 14
    call read_sector
    add sp, 4

;Phrase 2: Find the corresponding "loader.bin" entry
    mov di, bx
    mov cx, 11
COMPARE_NAME:
    mov si, [bp + 8]
CONTINUE_MATCH:
    lodsb
    cmp al, [es:di]
    jnz NEXT_ENTRY
    inc di
    loop CONTINUE_MATCH
    jmp ENTRY_FOUND
NEXT_ENTRY:
    dec word [dw_total_rootdir_entry]
    jz ALL_ROOTDIR_ENTRIES_READ
    and di, 0FFE0H  ; 32-bytes alignment
    add di, 20H     ; Next rootdir entry
    mov cx, 11
    jmp COMPARE_NAME

ALL_ROOTDIR_ENTRIES_READ:
    xor ax, ax
    jmp FAILED_RETURN

;Phrase 3: Load "loader.bin" into memroy
ENTRY_FOUND:
    and di, 0FFE0H
    add di, 1AH
    ; Display a dot for loading a sector
    push str_loading_dot
    call disp_str
    add sp, 2
    mov dx, [es:di]
    mov [dw_fat_table_entry], dx
CONTINUE_LOAD:
    add dx, 31
    push dx
    push 1
    call read_sector
    add sp, 4

    push word [dw_fat_table_entry]
    call get_fat_entry
    add sp, 2
    cmp ax, 0FF8H
    jae LOAD_OVER
    add bx, 200H
    mov [dw_fat_table_entry], ax
    mov dx, ax
    jmp CONTINUE_LOAD
LOAD_OVER:
    mov ax, 1
FAILED_RETURN:
    pop di
    pop si
    pop cx
    pop bx
    pop es
    leave
    ret
}}}

load_file可以分成三部分来看，对应源代码注释中的三个phrase：
 # 开始，load_file把根目录表的14个扇区都加载到向load_file传入的地址内；
 # 其次，遍历每一个根目录表项，找loader.bin对应的表项；
 # 最后，把找到的loader.bin逐个扇区的加载到load_file指定的缓冲区；

= The whole loading process =
有了上面这些辅助函数，我们MBR中的启动代码就非常简单了：
{{{
LABEL_START:
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, BASE_OF_STACK

    push str_boot_msg
    call disp_str
    add sp, 2

    ; Reset floopy disk
    xor ax, ax
    xor dx, dx
    int 13H

TRY_TO_RELOAD:
    push str_loader_name
    push OFFSET_OF_LOADER
    push BASE_OF_LOADER
    call load_file
    add sp, 6
    cmp ax, 1
    jnz LOAD_LOADER_FAILED
    jmp BASE_OF_LOADER:OFFSET_OF_LOADER
LOAD_LOADER_FAILED:
    jmp TRY_TO_RELOAD ; Try to reload the loader until successful
}}}

显示Booting，然后每读一个扇区会显示一个点，读成功了就跳转到Loader，否则就不停的读，一直到成功为止>_<。

= How to build? =
我们把编译出来的

至此，我们关于Bootloader这一部分的工作就全部结束了，意义非比寻常，因为有一个Loader，可以让你非常方便的调式Ring 0的代码。这样，你再也不会为写了一段保护模式代码无法正常工作的问题头疼了。虽然我们刚刚开始，但是你应该感到信心百倍了。